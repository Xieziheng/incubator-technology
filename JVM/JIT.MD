#JIT即时编译技术
##背景： 
   我们通常在发布或者服务器重启的时候发现有些机器的load会飙到非常高（查看线程，一般都是编译线程），并持续较长一段时间后回落注：load飙高的初始时刻是应用服务端口打开，且有流量进入。
出现这个原因就是jvm的一个预热过程尚未完成。dubbo的负载均衡权重中有设计到该点，但是只能说是简单的利用一个启动时间来进行判断系统的一个预热程度。有兴趣的可以去看看。Sentinel这里还是不错的，限流后有一种行为就是说我会逐步去进行预热，流量逐步增多从而使系统平稳的从冷系统进入热系统。
我们如果主动拿流量的话也应该注意这一点，就是说当你的系统处于冷系统的时候（代码未以机器码的形式存进内存，每一次方法调用都需要经历一个字节码转化为机器码的过程，这个时候你的业务处理速度会很慢，所以如果流量突增，会直接让整个系统GG），一定要平稳的加流量，而不能一次性大量流量导入，如果线上这样的情况发生，基本可以出门财务了。

##1：JIT简介 
   JIT 是 just in time 的缩写, 也就是即时编译编译器。使用即时编译器技术，能够加速 Java 程序的执行速度。
     
   首先，通常通过 javac 将程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。很显然，经过解释执行，其执行速度必然会比可执行的二进制字节码程序慢很多。为了提高执行速度，引入了 JIT 技术。
     
   在运行时 JIT 会把翻译过的机器码保存起来，以备下次使用，因此从理论上来说，采用该 JIT 技术可以接近以前纯编译技术。
     
   Java程序在启动的时候所有代码的执行都处于解释执行模式，只有在运行了一段时间后，根据代码方法执行的次数，或代码里循环的执行次数等达到一定的阈值才会编译成机器码，编译成机器码后执行效率会得到大幅提升，这个过程就是一个hot代码的处理，热区代码会被我们直接放入JIT编译区。
     
   在程序刚启动的时候，java还处于解释执行模式，因此服务效率很低，响应时间缓慢，处理得慢了，load自然也就高了。而当流量持续不断导入时，我们代码的很多方法执行次数不断增多，此时C2 CompilerThread线程不断收集优化信息，并且开始将一些热点代码优化编译成本地机器码，因此该线程的cpu使用率增高。而C2CompilerThread线程完成初始编译优化过程后，C2 CompilerThread线程的cpu使用率开始下降，与此同时优化后服务的性能大幅提升，服务响应时间也大大缩短，load也下降。



##2:JIT编译模式

JIT 编译器在运行程序时有两种编译模式可以选择，并且其会在运行时决定使用哪一种以达到最优性能。这两种编译模式的命名源自于命令行参数（eg: -client 或者 -server）。JVM Server 模式与 client 模式启动，最主要的差别在于：-server 模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。原因是：当虚拟机运行在-client 模式的时候，使用的是一个代号为 C1 的轻量级编译器，而-server 模式启动的虚拟机采用相对重量级代号为 C2 的编译器。C2 比 C1 编译器编译的相对彻底，服务起来之后，性能更高

   1:程序主动预热：在启动完成后，程序主动的访问热点的代码，确保主要的热点代码已被编译成机器码后再放入流量，可通过-XX:+PrintCompilation来确认。
   
   2:复制流量预热：通过tcpcopy软件拷贝一份线上nginx的流量进行预热，完成之后再导入线上流量。
   
启动多个线程进行编译优化
     如果能加快编译优化速度，那也能降低解释执行阶段导致的抖动时间。因此可以多拿几个线程来做编译，加快达到高峰性能的速度。
     可以使用-XX:CICompilerCount参数来设置编译线程数目，这个值默认是2（之前在栈里看到有两个编译线程），我们可以加到4。
     
3）采用多层编译

   编译方式有三种：1）Client模式；2）Server模式；3）Tiered模式。我们服务默认是Server模式。
      
   Server模式是采用c2高级编译的，会比较耗时且要运行一段时间才会触发编译。 Server模式的优点是编译后程序效率较高；
   Client模式比较轻量也比较快触发（比Server模式触发快），编译优化后程序效率不如Server模式；
   Tiered模式是Client模式和Server模式的折中，一开始会启用Client模式，可以在启动后更快的让部分代码先进入编译优化阶段，之后会启动Server模式，达到程序效率最大优化的目的。